import random
import re

import spacy
from geopy.geocoders import Nominatim

# assumption there can't be 20 cities with the same name at different locations
option_map = {
    "first": 0,
    "prior": 0,
    "previous": 0,
    "second": 1,
    "third": 2,
    "fourth": 3,
    "fifth": 4,
    "sixth": 5,
    "seventh": 6,
    "eighth": 7,
    "ninth": 8,
    "tenth": 9,
    "eleventh": 10,
    "twelfth": 11,
    "thirteenth": 12,
    "fourteenth": 13,
    "fifteenth": 14,
    "sixteenth": 15,
    "seventeenth": 16,
    "eighteenth": 17,
    "nineteenth": 18,
    "twentieth": 19,
    "last": -1,
    "this": -1
}

# same place alias, used to handle mismatch in OpenStreetMap API
place_alias = {
    "United States of America": 'USA'
}


class Location:
    def __init__(self):
        self.city = ''
        self.state = ''
        self.country = ''

    def __eq__(self, other):
        if not isinstance(other, Location):
            return NotImplemented
        return self.city == other.city and self.state == other.state and self.country == other.country


# class city is used for storing and retriving Location information from input sentence
class CityParser:
    questions = ["Where do you live?",
                 "Where are you from?",
                 "Where are you located?",
                 "Where are you based?",
                 "What is your address?"]
    debug = False
    nlp = spacy.load("en_core_web_sm")
    geolocator = Nominatim(user_agent='ECE496_group_undefined')

    # internal state of the parser, specific to each parsing session
    class State:
        def __init__(self):
            self.follow_up = False
            self.conversation_started = False
            self.mutiple_locations_with_same_name = False
            self.mutiple_cities_in_sentence = False
            self.parse_complete = False
            self.parse_unsuccessful = False

    # the object only contains members:city, state, country
    def __init__(self):
        self.location = Location()
        self.cur_answer = ""
        self.state = CityParser.State()
        # used for asking followup question
        self.followup_question = ""
        # answer expected from followup question
        self.expected_answers = []
        # the list of Locations we boil down to
        self.candidate_cities = []
        self.responses = []

    def __iter__(self):
        while not self.state.parse_complete:
            # start the conversation:
            if not self.state.conversation_started:
                index = random.randint(0, len(CityParser.questions) - 1)
                yield CityParser.questions[index]
            elif self.state.parse_unsuccessful:
                break
            elif self.state.mutiple_locations_with_same_name:
                yield self.followup_question
            elif self.state.mutiple_cities_in_sentence:
                yield self.followup_question
            elif self.state.parse_complete:
                break
            else:
                yield NotImplementedError
        self.state.conversation_started = False

    def ask(self):
        index = random.randint(0, len(CityParser.questions) - 1)
        return CityParser.questions[index]

    def add_response(self, response):
        # previous user input
        self.responses.append(self.cur_answer)
        # current input
        self.cur_answer = response.strip()

    def engage_conversation(self):
        self.find_city()

    def dump_result(self):
        print("Dumping city information:")
        print("\tCity:", self.location.city)
        print("\tState:", self.location.state)
        print("\tCountry:", self.location.country)

    def reply(self, ans):
        self.cur_answer = ans
        return self.find_city()

    # input name of a location or alias
    # output the proper name of that same location
    # i.e. map The United State of America to USA
    def check_alias(self, location):
        location = location.strip()
        if (location in place_alias.keys()):
            return place_alias[location]
        else:
            return location

    # input:
    # doc      the tokens generated by Spacy
    # entity   one entity that is in the same string of doc
    # return the left pronouns string that follows immediately before the giving entity
    def look_left(self, doc, entity):
        prefix = []
        # going from right to left
        for token in reversed(doc):
            # look at the tokens that are left to the entity
            if (token.idx < entity.start_char):
                if self.debug:
                    print(token.text, "tag", token.tag_)
                # if it's a pronone or a comma or number
                if (token.tag_ == 'NNP' or token.tag_ == ',' or token.tag_ == 'CD'):
                    matchObj = re.match("^[\w,-]+$", token.text)  # delete some unwanted character
                    if matchObj:
                        prefix.append(token.text)
                    else:
                        break
                else:
                    break
        if (len(prefix)) > 0:
            prefix = ' '.join(reversed(prefix))
        else:
            prefix = ''
        if self.debug:
            print('prefix:', prefix)
        return prefix

    # input:
    # doc    the tokens generated by Spacy
    # entity one entity that is in the same string
    # return the right pronouns string that follows immediately after the giving entity
    def look_right(self, doc, entity):
        suffix = []
        for token in doc:
            # look at the tokens that are right to the entity
            if (token.idx >= entity.end_char):
                if self.debug:
                    print(token.text, "tag", token.tag_)
                # if it's a pronone or a comma or number
                if (token.tag_ == 'NNP' or token.tag_ == ',' or token.tag_ == 'CD'):
                    matchObj = re.match("^[\w,-]+$", token.text)  # delete some unwanted character
                    if matchObj:
                        suffix.append(token.text)
                    else:
                        break
                else:
                    break
        if (len(suffix) > 0):
            suffix = ' '.join(suffix)
        else:
            suffix = ''
        if self.debug:
            print('suffix:', suffix)
        return suffix

    # helper function to determine if city variable has been set
    def is_city_found(self):
        if (self.location.city != '' and self.location.state != '' and self.location.country != ''):
            return True
        return False

    def get_unique_valid_list(self, input_list, city_name):
        unique_list = []
        for current_location in input_list:
            is_current_location_unique = True
            for unique_location in unique_list:
                if (current_location == unique_location):
                    is_current_location_unique = False
                    break
            if (is_current_location_unique):
                unique_list.append(current_location)
        unique_list_without_invalid_addr = []
        # do a second pass to see if we can start to remove some of the location that have cannot_be_found
        for unique_location in unique_list:
            if (unique_location.city != "cannot_be_found"):
                unique_list_without_invalid_addr.append(unique_location)
        # the list with all valid 'city' parameter
        if len(unique_list_without_invalid_addr) > 0:
            return unique_list_without_invalid_addr
        else:  # the list of addresses all do not have city name parameter, in this case we just set to the city name entity found through spacy
            for unique_location in unique_list:
                unique_location.city = city_name
            return unique_list

    # use geopy to check if given named entity is a city name (or a GPE entity name from spacy)
    # return true if it's a city name, otherwise return False
    def is_entity_a_city(self, city_name):
        try:
            # it might return a list of locations
            locations = self.geolocator.geocode(city_name, addressdetails=True, exactly_one=False, timeout=20)
            if locations is not None:  # if there are some locations that can be found in OpenStreetMap
                # go over all the possible cities and search if it's really a city
                for location in locations:
                    if self.debug:
                        print(location.raw)
                        # best case the input has been labeled as a city
                    if 'type' in location.raw.keys() and location.raw['type'] == 'city':
                        return True
                    elif 'type' in location.raw.keys() and (
                            location.raw['type'] == 'embassy' or location.raw['type'] == 'diplomatic'):
                        return False
                    elif 'address' in location.raw.keys() and 'city' in location.raw[
                        'address'].keys() and city_name.find(
                        location.raw['address']['city']) >= 0:  # if the city name is a substring of input city_name
                        return True
            return False
        except:
            return False

    # use spacy build in named entity filter to find all possible geo-location, with a feature that will grab any immediate pronouns left or right to the named_entity
    # return list of geo location entities (that can be found in OpenStreetMap) if any geo location can be found
    # otherwise return empty list
    def spacy_geo_entity_filter(self, cur_answer):
        # list of strings that contain possible geo-location names
        possible_geo_locations = []
        doc = CityParser.nlp(cur_answer)

        for ent in doc.ents:
            if self.debug:
                print('current entity:', ent.text, 'current tag:', ent.label_)
            if ent.label_ == 'GPE' or ent.label_ == 'LOC' or ent.label_ == 'FAC' or ent.label_ == 'PERSON':  # or ent.label_=='ORG':
                if self.debug:
                    print('found a geo location entity:', ent.text)
                    # look at the left side of the entity to see if there is any NNP next to it
                prefix = self.look_left(doc, ent)
                # look at the right side of the entity to see if there is any NNP next to it
                suffix = self.look_right(doc, ent)
                # append the prefix and suffix together, Note this action might result in a situation like 'Richmond Hill Ontario Canada' joint together
                possible_city = ''
                if (prefix):
                    possible_city = prefix + ' ' + ent.text
                else:
                    possible_city = ent.text
                if (suffix):
                    possible_city = possible_city + ' ' + suffix
                if self.debug:
                    print('city :\'' + possible_city + '\'')
                    # check if it's a city
                if (self.is_entity_a_city(possible_city)):
                    possible_geo_locations.append(possible_city)
        return list(set(possible_geo_locations))  # reduce to a list with unique geo entities

    # input:
    # sentence  input sentence that might contain geo location information
    # output:
    # list of entities that can be found inside OpenStreetAPI
    def check_noun_filter(self, sentence):
        is_prev_noun = False
        possible_entity_location = []
        cities_found = []
        doc = CityParser.nlp(sentence)
        for token in doc:
            # handle the case like 123 Cobblestone
            if (token.tag_ == 'CD' or token.tag_ == 'NNP' or token.tag_ == 'NN' or token.tag_ == 'NNPS'):
                if is_prev_noun == True:
                    possible_entity_location.append(token.text)
                else:
                    possible_entity_location = [token.text]
                    is_prev_noun = True
            else:
                if (len(possible_entity_location) > 0):
                    # check if last entity is a city location
                    possible_entity = ' '.join(possible_entity_location)
                    if (self.is_entity_a_city(possible_entity)):
                        cities_found.append(possible_entity)
                is_prev_noun = False
        # check if last entity is a city location
        if len(possible_entity_location) > 0:
            possible_entity = ' '.join(possible_entity_location)
            if (self.is_entity_a_city(possible_entity)):
                cities_found.append(possible_entity)
        return cities_found

    # internal helper function that take a list of list of expected answers each row of the array represent the possible forms of one expected answer(i.e. ['Toronto', 'Tor']) and user_input (string)
    # return an index corresponding to which expected answer the user has selected, return -1 if none of the expected answer is in the user input
    def which_answer(self, user_input, expected_answers):
        user_selected = -1
        user_input = user_input.lower()
        max_number_of_match = 0
        # first level of parser, to a substring match
        for index in range(0, len(expected_answers)):
            form_of_answers = expected_answers[index]
            current_number_of_match = 0
            for expected_answer in form_of_answers:
                # if current form of answer exist in user input
                if (user_input.find(expected_answer.lower()) >= 0):
                    current_number_of_match = current_number_of_match + 1
            if current_number_of_match > max_number_of_match:
                max_number_of_match = current_number_of_match
                user_selected = index
        # second level of match, maybe the user give out an answer like 'first one'
        if max_number_of_match == 0:
            for key in option_map.keys():
                if user_input.find(key) != -1:
                    user_selected = option_map[key]
                    if user_selected == -1:  # map -1 to the last element of the array
                        user_selected = len(expected_answers) - 1
                        break
        return user_selected

    def is_city_names_same(self, locations):
        is_city_name_same = True
        previous_city_name = ''
        if len(locations) > 0:
            previous_city_name = locations[0].city
        else:
            return True
        for index in range(1, len(locations)):
            if (locations[index].city != previous_city_name):
                return False
            previous_city_name = locations[index].city
        return True

    # internal helper function that helps to format followup questions and expected answers
    # only allow state, country or country+state to be different
    # possible_cities    list of possible locations
    # return: followup question, list of expected answers
    def follow_up_which_location(self, possible_cities):
        is_city_same = self.is_city_names_same(possible_cities)
        is_state_same = True
        is_country_same = True
        possible_answers = []
        for index in range(0, len(possible_cities) - 1):
            if possible_cities[index].state != possible_cities[index + 1].state:
                is_state_same = False
            if possible_cities[index].country != possible_cities[index + 1].country:
                is_country_same = False
        question = ''
        if is_state_same:
            # ask follow up question about which country, since we have multiple candidate
            question = "can you tell me which country is your city located in? Is it"
        elif is_country_same:
            # ask follow up question about which state, since we have multiple candidate
            question = "can you tell me which state is your city located in? Is it"
        else:
            # ask follow up question about which state and country since we have multiple candidate
            question = "can you tell me which city your are referring to? Is it"

        for index in range(0, len(possible_cities) - 1):
            # only difference is in the country
            if is_state_same and is_country_same == False:
                if is_city_same:
                    question = question + " " + str(possible_cities[index].country) + ","
                    expected_answer = [str(possible_cities[index].country)]
                    possible_answers.append(expected_answer)
                else:
                    question = question + " " + str(possible_cities[index].city) + " in " + str(
                        possible_cities[index].country) + ","
                    expected_answer = [str(possible_cities[index].city), str(possible_cities[index].country)]
                    possible_answers.append(expected_answer)
                    # only difference is the state
            elif is_country_same and is_state_same == False:
                if is_city_same:
                    question = question + " " + str(possible_cities[index].state) + ","
                    expected_answer = [str(possible_cities[index].state)]
                    possible_answers.append(expected_answer)
                else:
                    question = question + " " + str(possible_cities[index].city) + " in " + str(
                        possible_cities[index].state) + ","
                    expected_answer = [str(possible_cities[index].city), str(possible_cities[index].state)]
                    possible_answers.append(expected_answer)
                    # state and country are both different
            else:
                if is_city_same:
                    question = question + " " + str(possible_cities[index].state) + " in " + str(
                        possible_cities[index].country) + ","
                    expected_answer = [str(possible_cities[index].state), str(possible_cities[index].country)]
                    possible_answers.append(expected_answer)
                else:
                    question = question + " " + str(possible_cities[index].city) + " in " + str(
                        possible_cities[index].state) + " " + str(possible_cities[index].country) + ","
                    expected_answer = [str(possible_cities[index].city), str(possible_cities[index].state),
                                       str(possible_cities[index].country)]
                    possible_answers.append(expected_answer)
                    # remove last comma
        question = question[:len(question) - 1]
        # append the last option
        if (len(possible_cities) >= 2):
            if is_state_same and is_country_same == False:
                if is_city_same:
                    question = question + " or " + str(possible_cities[-1].country) + "?"
                    expected_answer = [str(possible_cities[-1].country)]
                    possible_answers.append(expected_answer)
                else:
                    question = question + " or " + str(possible_cities[-1].city) + " in " + str(
                        possible_cities[-1].country) + "?"
                    expected_answer = [str(possible_cities[-1].city), str(possible_cities[-1].country)]
                    possible_answers.append(expected_answer)
            elif is_country_same and is_state_same == False:
                if is_city_same:
                    question = question + " or " + str(possible_cities[-1].state) + "?"
                    expected_answer = [str(possible_cities[-1].state)]
                    possible_answers.append(expected_answer)
                else:
                    question = question + " or " + str(possible_cities[-1].city) + " in " + str(
                        possible_cities[-1].state) + "?"
                    expected_answer = [str(possible_cities[-1].city), str(possible_cities[-1].state)]
                    possible_answers.append(expected_answer)
            else:
                if is_city_same:
                    question = question + " or " + str(possible_cities[-1].state) + " in " + str(
                        possible_cities[-1].country) + "?"
                    expected_answer = [str(possible_cities[-1].state), str(possible_cities[-1].country)]
                    possible_answers.append(expected_answer)
                else:
                    question = question + " or " + str(possible_cities[-1].city) + " in " + str(
                        possible_cities[-1].state) + " " + str(possible_cities[-1].country) + "?"
                    expected_answer = [str(possible_cities[-1].city), str(possible_cities[-1].state),
                                       str(possible_cities[-1].country)]
                    possible_answers.append(expected_answer)

        return question, possible_answers

    # input
    # ans                 user input
    # expected_answers    list of keywords that can indicate the correct answer
    # cities              list of possible cities
    # return
    # True if location can be set, otherwise return False
    def set_followup_location(self, ans, expected_answers, cities):
        option = self.which_answer(ans, expected_answers)
        if option != -1:
            # set the final location
            self.location.city = cities[option].city
            self.location.state = cities[option].state
            self.location.country = cities[option].country
            return True
        return False

    # input
    # an city entity that can be found inside the OpenStreetMap
    # the input sentence
    # output list of Locations that matches with given city_name, otherwise return false
    def set_city(self, city_name, sentence):
        try:
            locations = self.geolocator.geocode(city_name, addressdetails=True, exactly_one=False,
                                                timeout=20)  # might time out due to connection issue
            possible_cities = []
            possible_cities_and_states = []
            possible_cities_and_counties = []
            # remove extra spaces like 2 spaces
            sentence = ' '.join(sentence.split())
            sentence = sentence.lower()
            for location in locations:
                if self.debug:
                    print(location.raw)
                    # if there is a city inside OpenStreetMap that matches the input city
                if (('type' in location.raw.keys() and location.raw['type'] == 'city') or (
                        'address' in location.raw.keys() and 'city' in location.raw[
                    'address'].keys() and city_name.lower().find(
                    location.raw['address']['city'].lower()) >= 0)):
                    # check if state is in the sentence, i.e. we have a matching city and state.
                    if ('state' in location.raw['address'].keys() and sentence.find(
                            str(location.raw['address']['state']).lower()) >= 0):
                        # if country is in the sentence i.e. we have a matching city, state and country. Then we can say we found a match
                        if ('country' in location.raw['address'].keys() and sentence.find(
                                str(location.raw['address']['country']).lower()) >= 0):
                            # set the city location to the name in OpenStreetMap API or treat this OpenStreetMap node as invalid
                            if 'city' in location.raw['address'].keys():
                                self.location.city = self.check_alias(location.raw['address']['city'])
                            elif 'county' in location.raw['address'].keys():
                                self.location.city = self.check_alias(location.raw['address']['county'])
                            else:
                                self.location.city = 'cannot_be_found'  # continue
                            # set the state location
                            self.location.state = self.check_alias(location.raw['address']['state'])
                            # set the country location
                            self.location.country = self.check_alias(location.raw['address']['country'])
                            if self.debug:
                                print("Full match, city, state, country are in the sentence")
                            return True
                        # the country parameter didn't match
                        else:
                            temp_location = Location()
                            if 'city' in location.raw['address'].keys():
                                temp_location.city = self.check_alias(location.raw['address']['city'])
                            elif 'county' in location.raw['address'].keys():
                                temp_location.city = self.check_alias(location.raw['address']['county'])
                            else:
                                temp_location.city = 'cannot_be_found'  # continue
                            temp_location.state = self.check_alias(location.raw['address']['state'])
                            if 'country' in location.raw['address'].keys():
                                temp_location.country = self.check_alias(location.raw['address']['country'])
                            else:
                                print("missing country inforamtion in OpenStreetMap API for", city_name)
                                return False
                            if self.debug:
                                print("missing country")
                            possible_cities_and_states.append(temp_location)
                    # state information is not in the sentence,
                    # check if country is in the sentence, i.e. we have a matching city and country
                    elif ('country' in location.raw['address'].keys() and sentence.find(
                            str(location.raw['address']['country']).lower()) >= 0):
                        temp_location = Location()
                        if 'city' in location.raw['address'].keys():
                            temp_location.city = self.check_alias(location.raw['address']['city'])
                        elif 'county' in location.raw['address'].keys():
                            temp_location.city = self.check_alias(location.raw['address']['county'])
                        else:
                            temp_location.city = 'cannot_be_found'  # continue
                        if 'state' in location.raw['address'].keys():
                            temp_location.state = self.check_alias(location.raw['address']['state'])
                        else:
                            print("Missing state information in OpenStreetAPI for", city_name)
                            return False
                        temp_location.country = self.check_alias(str(location.raw['address']['country']))
                        if self.debug:
                            print('missing state')
                            print('city', temp_location.city)
                            print('state', temp_location.state)
                            print('country', str(temp_location.country))
                            print('end of print')

                        possible_cities_and_counties.append(temp_location)
                    # can't find any state and country information
                    else:
                        temp_location = Location()
                        if 'city' in location.raw['address'].keys():
                            temp_location.city = self.check_alias(location.raw['address']['city'])
                        elif 'county' in location.raw['address'].keys():
                            temp_location.city = self.check_alias(location.raw['address']['county'])
                        else:
                            temp_location.city = 'cannot_be_found'  # continue
                        if 'state' in location.raw['address'].keys():
                            temp_location.state = self.check_alias(location.raw['address']['state'])
                        else:
                            print("Missing state information in OpenStreetMap API for", city_name)

                        if 'country' in location.raw['address'].keys():
                            temp_location.country = self.check_alias(location.raw['address']['country'])
                        else:
                            print("Missing country information in OpenStreetMap API for ", city_name)
                            return False
                        if self.debug:
                            print('only city can be found')
                        possible_cities.append(temp_location)
            possible_cities_and_counties = self.get_unique_valid_list(possible_cities_and_counties, city_name)
            possible_cities_and_states = self.get_unique_valid_list(possible_cities_and_states, city_name)
            possible_cities = self.get_unique_valid_list(possible_cities, city_name)

            # if there is only one city in any of the above 3 types of combinations, then we say we have found a match
            if (len(possible_cities_and_counties) == 1):
                # return possible_cities_and_counties
                self.location.city = possible_cities_and_counties[0].city
                self.location.state = possible_cities_and_counties[0].state
                self.location.country = possible_cities_and_counties[0].country
                return True
            if (len(possible_cities_and_states) == 1):
                # return possible_cities_and_states
                self.location.city = possible_cities_and_states[0].city
                self.location.state = possible_cities_and_states[0].state
                self.location.country = possible_cities_and_states[0].country
                return True
            if (len(possible_cities) == 1):
                # return possible_cities
                self.location.city = possible_cities[0].city
                self.location.state = possible_cities[0].state
                self.location.country = possible_cities[0].country
                return True
            # all of the array has lenght >=2 or ==0 case
            number_of_candidate_cities = len(possible_cities) if len(possible_cities) > 0 else float('Inf')
            number_of_candidate_cities_and_countries = len(possible_cities_and_counties) if len(
                possible_cities_and_counties) > 0 else float('Inf')
            number_of_candidate_cities_and_states = len(possible_cities_and_states) if len(
                possible_cities_and_states) > 0 else float('Inf')
            min_value = min(number_of_candidate_cities, number_of_candidate_cities_and_countries,
                            number_of_candidate_cities_and_states)
            if (min_value == 'Inf'):
                return False
            else:
                if min_value == number_of_candidate_cities:
                    return possible_cities
                elif min_value == number_of_candidate_cities_and_states:
                    return possible_cities_and_states
                else:
                    return possible_cities_and_counties
        except:
            return False

    # a function that will take a list of entities that are cities and tries to distiguish which city is the one
    def which_city(self, list_of_cities, sentence):
        question = 'Sorry is it'
        possible_answers = []
        for index in range(0, len(list_of_cities) - 1):
            question = question + " " + list_of_cities[index] + ","
            possible_answers.append([list_of_cities[index]])
        # remove last ','
        question = question[:len(question) - 1]
        # add the last option
        question = question + ' or ' + list_of_cities[-1] + '?'
        possible_answers.append([list_of_cities[-1]])
        return question, possible_answers
        '''
        option=-1
        user_input=''
        while option<0 or option>=len(list_of_cities):
          user_input=input(question+"\n>>>")
          option=self.which_answer(user_input,possible_answers)
        self.cur_answer= self.cur_answer +' '+user_input.strip()
        return option
        '''

    # function that tries to find a city within a sentence and update the state variable
    # we should apply different set of named entity filter and see which one worked
    def find_city(self):
        assert (len(self.cur_answer))
        if not self.state.conversation_started:
            if self.cur_answer == "no":
                self.state.conversation_started = True
                self.state.parse_unsuccessful = True
                return
            # first level of filter - spacy build in named entity recognition
            possible_locations = self.spacy_geo_entity_filter(self.cur_answer)
            if (len(possible_locations) == 0):
                # second level of filter - search for all nouns inside the sentence
                possible_locations = self.check_noun_filter(self.cur_answer)
            if (len(possible_locations) > 0):
                # one city case
                if (len(possible_locations) == 1):
                    set_city_locations = self.set_city(possible_locations[0], self.cur_answer)
                    # there are mutiple cities with the same name
                    if (isinstance(set_city_locations, list)):
                        # format the follow up question and expected answer
                        self.followup_question, self.expected_answers = self.follow_up_which_location(
                            set_city_locations)
                        # store the candidate cities
                        self.candidate_cities = set_city_locations
                        # change state variable to mutiple_locations_with_same_name
                        self.state.mutiple_locations_with_same_name = True
                    # set_city operation is successful, exit conversation
                    else:
                        if set_city_locations:
                            self.state.parse_complete = True
                        else:
                            self.state.parse_unsuccessful = True
                # there are two or cities Location in the sentence
                else:
                    # generate follow up question about which named_entity is it?
                    self.followup_question, self.expected_answers = self.which_city(possible_locations, self.cur_answer)
                    self.state.mutiple_cities_in_sentence = True
                self.state.conversation_started = True
                return  # end of start conversation
            else:  # can't find any city information
                self.state.conversation_started = False
        elif self.state.mutiple_cities_in_sentence:
            if self.cur_answer == "no":
                self.state.parse_unsuccessful = True
                return
            supplement_answer = self.cur_answer
            city_index = self.which_answer(supplement_answer, self.expected_answers)
            if city_index != -1:
                # add the answer to the followup question to the answer stored in this object
                for previous_answer in self.responses:
                    supplement_answer = supplement_answer + ' ' + previous_answer
                # There is only one city left
                set_city_locations = self.set_city(self.expected_answers[city_index], self.cur_answer)
                # there are mutiple cities with the same name
                if (isinstance(set_city_locations, list)):
                    # format the follow up question and expected answer
                    self.followup_question, self.expected_answers = self.follow_up_which_location(set_city_locations)
                    # store the candidate cities
                    self.candidate_cities = set_city_locations
                    # change state variable to mutiple_locations_with_same_name
                    self.state.mutiple_locations_with_same_name = True
                else:  # if set city operation can be complete without asking followup question
                    if set_city_locations:
                        self.state.parse_complete = True
                    else:
                        self.state.parse_unsuccessful = True
                self.state.mutiple_cities_in_sentence = False
                return
            else:  # invalid input, stay in current state
                return
        elif self.state.mutiple_locations_with_same_name:
            if self.cur_answer == "no":
                self.state.parse_unsuccessful = True
            answer = self.cur_answer
            for previous_answer in self.responses:
                answer = answer + ' ' + previous_answer
            is_answer_valid = self.set_followup_location(answer, self.expected_answers, self.candidate_cities)
            if is_answer_valid:
                self.state.parse_complete = True
                self.state.mutiple_locations_with_same_name = False
                return
            # else
            # the user entered a response that can't be understood, ask the same question again
        elif self.state.parse_complete:
            return
        elif self.state.parse_unsuccessful:
            return
        else:
            assert (False and "unknown state")


if __name__ == '__main__':

    # loop through test case
    city_obj = CityParser()

    questions = ["I'm currently living in New York",
                 "I'm from Rio de Janeiro",
                 "I’m from The United Kingdom of Great Britain and Northern Ireland",
                 "I live in Little Rock",
                 "I'm in Salt Lake City",
                 "Toronto",
                 "toronto",
                 "I live on broadway",
                 "I live in China",
                 "I commute across London and Toronto",
                 "I live in Downtown Toronto",
                 "I am from Edmonton",
                 "I live in the city of Toronto",
                 "I live near Yonge and Dundas",
                 "I am based in 5901 Yonge Street, Toronto",
                 "I live near Chintown",
                 "I cannot tell you",
                 "Why do you ask",
                 "I live at 1 Commerce Valley Dr East, Markham"]

    for testCase in questions:
        city_obj = CityParser()
        counter = 0
        for question in city_obj:
            print(question)
            if counter == 0:
                print(testCase)
                city_obj.add_response(testCase)
            else:
                ans = input("\n>>>")
                city_obj.add_response(ans)
            city_obj.engage_conversation()
            counter += 1
        city_obj.dump_result()

    '''
    for question in city_obj:
        print(question)
        ans=input("\n>>>")
        city_obj.add_response(ans)
        city_obj.engage_conversation()
    city_obj.dump_result()
    '''

    '''
    #test individual case
    sentence="I live in China"#"I’m from The United Kingdom of Great Britain and Northern Ireland"#"I live in Memphis USA"#"I'm living in Little Rock city"#"I'm living in Richmond Hill"#"I'm living in Richmond Hill Ontario Canada"#"I was living in London. But recently moved to New York"#"I live in Springfield." 
    city_obj.sentence=sentence
    city_obj.find_city()
    
    
    city_obj = CityParser()
  
    #deal with real user input
    
    while(city_obj.is_city_found()==False):
      city_obj.ask()
      city_obj.find_city()
    '''
